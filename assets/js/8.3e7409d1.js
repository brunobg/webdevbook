(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{358:function(e,t,a){"use strict";a.r(t);var o=a(43),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"architecture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#architecture"}},[e._v("#")]),e._v(" Architecture")]),e._v(" "),a("p",[e._v("There are several considerations when you start an application. This section will details some basic choices you have to make.")]),e._v(" "),a("h2",{attrs:{id:"server-side-render-versus-spas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#server-side-render-versus-spas"}},[e._v("#")]),e._v(" Server-side render versus SPAs")]),e._v(" "),a("p",[e._v("Originally the web worked in a simple way: the server sent HTML ready for the browser to render and show. There was no dynamic data transference between the browser and the server; everything was a HTML page. With Javascript appearing and XHR (ajax), it became possible to fetch data without navigating to a new page. Eventually some people started to implement the entire generation of HTML on the client, and the server only sent pure data in JSON or XML formats. So Single Page Applications were born.")]),e._v(" "),a("p",[e._v("The advantage of SPAs is to keep the entire frontend generation on the client, which becomes easier with reactive JS frameworks such as Vue or React. This way all the communication with the server is either serving static assets (JS, images, or the very basic HTML page that is used as base for loading) or serving data from the DB. It becomes possible to move all static assets to a CDN, and clients only have to load them once, making navigation faster. It also makes the backend easier to write, because you don't have to worry about HTML or rendering at all. You just write endpoints to get data. The servers need to do much less processing, therefore their load is also much lighter.")]),e._v(" "),a("p",[e._v("SPAs have a much longer loading phase, however. Clients need to download the base HTML, then the JS for rendering (which can be megabytes), and only when the JS is finished downloading it runs, setups what is needs and requests the actual dynamic data from the server. The data is downloaded and the JS processes it to generate HTML, which the browser renders. As a result, it's one or two orders of magnitude slower on the client than server-side rendering. If you don't take care you end up with a site that takes several seconds to load, which is not a good user experience.")]),e._v(" "),a("p",[e._v("SPAs are attractive for another reason: there's a separation of frontend and backend into different code bases, which become completely independent. This makes it easier for teams to work on the same project and reduces the possibility of breakage, as long as you take care that the data transference follows the expected format.")]),e._v(" "),a("p",[e._v("We are taking a SPA approach in this book. In our case we are also developing a mobile app, so it makes sense that the backend will be only one, serving the same data for web and mobile. It also makes it easier to write code for the frontend, since you only have to write the communication code once.")]),e._v(" "),a("p",[e._v("That doesn't mean that server-side rendering is dead. In fact we'll see that if we want to provide page previews with metadata, we'll have to some at least some server-side rendering. Most automated tools will download the HTML and not run the JS, so they only see what the server outputs. Indexers such as Google run JS these days, so they can index your site properly, but most crawlers, as well as preview fetchers from chat apps for example, don't.")]),e._v(" "),a("p",[e._v("In sites that are not very interactive, SPAs might slow make them slower with little gain. If you have static data you can pre-render the HTML on the server easily -- that's how this book is generated, pre-rendered into HTML that you download.")]),e._v(" "),a("p",[e._v('Considering the advantages of SSR, we went full circle and started to essentially "run the frontend SPA on the server". The browser downloads a pre-rendered HTML page with data, then it runs the SPA code to make the page reactive and dynamic, which is called hydrating. Of course, this complicates things again. You need Node.js to run the frontend JS code on the server, and you increase the server load. As always, it\'s a trade-off.')]),e._v(" "),a("p",[e._v("In this book we'll do SPA approach where we do not pre-render or SSR the page, but we fill the metadata to make previews possible. It's up to you whether to follow this approach. Laravel can use Blade templates to render content statically, which might be more fitting for your problem.")]),e._v(" "),a("h2",{attrs:{id:"graphql-or-rest"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#graphql-or-rest"}},[e._v("#")]),e._v(" GraphQL or REST?")]),e._v(" "),a("p",[e._v("There are currently three most popular standards that are used to transfer data between server and clients by polling: SOAP, REST and GraphQL.")]),e._v(" "),a("p",[e._v("SOAP, Simple Object Access Protocol, is a standaard protocol originally developed by Microsoft. SOAP has a more rigid set of rules and relies on XML to transfer data. SOAP is integrated into some technologies such as DCOM and CORBA. We'll not discuss it further here.")]),e._v(" "),a("p",[e._v("REST (Representational State Transfer) is a very popular transfer technology. The idea is that you have endpoints mapped to web routes, such as \"/post/[id]\". REST is lightweight and usually transfers JSON, but you can pick whatever data format it's more useful -- even more than one. HTTP provides action verbs (GET, POST, PUT and DELETE), which indicate which operation is being performed. REST is populare because it's easy to implement: you write code for the endpoint in a controller and you're running.")]),e._v(" "),a("p",[e._v("GraphQL is a query language for APIs. It is also a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API. It is more powerful since the client can decide what information it wants. It was originally developed by Facebook and used internally, and now it's controlled by a foundation under the Linux Foundation. Nowadays it is supported by good tools and has a pleasant side-effect -- you don't need to write communication code anymore. In fact, in the approach favored by this book you don't have to write controllers. The GraphQL library does it for you, and you get basic CRUD operation for free. There's only one endpoint and there's a language to describe data, queries and mutations. GraphQL also lets you subscribe to data, therefore providing push communication as well.")]),e._v(" "),a("p",[e._v("You can use GraphQL and REST in the same application. They are not even exactly the same thing. But GraphQL with a proper library is very easy to use and makes you write way less code. We'll see that it has enough information to even help us to avoid not only writing controllers, but generating a lot of the code we'll need automatically.")]),e._v(" "),a("h2",{attrs:{id:"designing-your-application"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#designing-your-application"}},[e._v("#")]),e._v(" Designing your application")]),e._v(" "),a("p",[e._v("This is arguably the most important part of your application, and certainly the one that requires most thought in its design.")]),e._v(" "),a("h3",{attrs:{id:"what-types-do-you-have-in-your-system"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-types-do-you-have-in-your-system"}},[e._v("#")]),e._v(" What types do you have in your system?")]),e._v(" "),a("p",[e._v("The first question you have to ask yourself is what types your system will have.")]),e._v(" "),a("p",[e._v("You almost certainly will have "),a("code",[e._v("Users")]),e._v(". What do they do? If it's a communication system for example, they might create "),a("code",[e._v("Posts")]),e._v(" and add "),a("code",[e._v("Comments")]),e._v(" to the posts, and probably giving "),a("code",[e._v("Ratings")]),e._v(".")]),e._v(" "),a("p",[e._v("Or you are building an ecommerce store. Perhaps it has "),a("code",[e._v("Users")]),e._v(" to save their information, but you might be selling without even creating a "),a("code",[e._v("User")]),e._v(" entry and storing it all on the invoice. But you have "),a("code",[e._v("Products")]),e._v(", which might have "),a("code",[e._v("Reviews")]),e._v(", and the "),a("code",[e._v("Invoices")]),e._v(" for purchases. But invoices are a complex type, with several rows of different data. So you might want an "),a("code",[e._v("InvoiceItem")]),e._v(" type with the product purchasen, the amount and price, and who bought it.")]),e._v(" "),a("h3",{attrs:{id:"what-are-the-relationships"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-are-the-relationships"}},[e._v("#")]),e._v(" What are the relationships?")]),e._v(" "),a("p",[e._v("Remember, SQL databases do not have arrays as a primary datatype, so whenever you have an array it's probably better to store it as a relationship with another type -- like the "),a("code",[e._v("InvoiceItem")]),e._v(" example. The relationships can be one-to-one, one-to-many or many-to-many. It may be a good idea to draw an ER diagram with your modeling.")]),e._v(" "),a("h3",{attrs:{id:"what-queries-to-do-need"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-queries-to-do-need"}},[e._v("#")]),e._v(" What queries to do need?")]),e._v(" "),a("p",[e._v("It's likely that you'll want to list the entries of a certain type, and fetch information about a specific entry. What about other queries? Perhaps searching products by name, or listing all posts with a specific tag.")]),e._v(" "),a("h3",{attrs:{id:"what-mutations-are-possible-on-each-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-mutations-are-possible-on-each-type"}},[e._v("#")]),e._v(" What mutations are possible on each type?")]),e._v(" "),a("p",[e._v("You need to be able to create a type instance, such as a new "),a("code",[e._v("Post")]),e._v(" or new "),a("code",[e._v("Product")]),e._v(". Do you want to delete them though? You might want to keep them forever. What about editing? Can you change that instance after it's created? The basic operations on a type (CRUD, for Create, Read, Update, Delete) are not necessarily implemented for all types. You might not even want to expose a create operation if you have a limited, fix set of instances that are generated during the setup of your application -- for example, t-shirt sizes.")]),e._v(" "),a("p",[e._v("With GraphQL all the operations that generate changes to the database are called "),a("em",[e._v("mutations")]),e._v(". We're going to list all mutations and organize them with the model type definition to make them easier to find. Sometimes creating can be a mutation in another type: for example, creating a comment can be a "),a("code",[e._v("commentPost")]),e._v(" mutation. Adding new pictures can be a "),a("code",[e._v("postPhoto")]),e._v(" mutation.")]),e._v(" "),a("p",[e._v("List the operations that you'll use.")]),e._v(" "),a("h3",{attrs:{id:"who-can-do-each-of-those-operations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#who-can-do-each-of-those-operations"}},[e._v("#")]),e._v(" Who can do each of those operations?")]),e._v(" "),a("p",[e._v("Not every operation can be done by every user. You don't want John changing Mary's profile, or Paul accessing Jane's invoices. So both queries and mutations need to be restricted with policies. For each item in your query and mutation list describe the restrictions. Do it from the start; it's better to have all endpoints blocked by default than to forget one of them.")])])}),[],!1,null,null,null);t.default=r.exports}}]);