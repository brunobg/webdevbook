(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{382:function(e,t,a){"use strict";a.r(t);var o=a(42),i=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"introduction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),a("p",[e._v("So you want to build the frontend for a native and web application. You don't want to implement three different versions in three different languages, for Web, Android and iOS. This book will explain one way to implement the entire frontend in JS, using HTML5 for web and Nativescript bindings for native apps. You can also ignore the Nativescript parts of the book if you are designing a pure HTML application with no prejudice at all.")]),e._v(" "),a("p",[e._v("We assume that you have some familiarity with Javascript and "),a("a",{attrs:{href:"https://vuejs.org",target:"_blank",rel:"noopener noreferrer"}},[e._v("VueJS"),a("OutboundLink")],1),e._v(". You might not have ever seen "),a("a",{attrs:{href:"https://nativescript.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("NativeScript"),a("OutboundLink")],1),e._v(" (TNS), which is an open source framework for building truly native mobile apps with Angular, Vue.js, TypeScript, or JavaScript, which compiles to iOS or Android applications; it's fine, we'll be a little more detailed about it and you can read its documentation for any details you need. We are adopting it because "),a("a",{attrs:{href:"https://nativescript-vue.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("it provides integration with VueJS"),a("OutboundLink")],1),e._v(" and we can share most of our code between Web and Native versions of the application, changing only the interface code. This solves a major problem of keeping web, iOS and Android versions of the same application and avoid maintaining three different code bases. With this approach we maintain a single code base, with two different view templates, HTML and TNS. It becomes closer to maintaining a web responsive application.")]),e._v(" "),a("p",[e._v("The frontend part of this book is about how to structure your code and how to solve the most common problems that we often face.")]),e._v(" "),a("h2",{attrs:{id:"mobile-native-js-pwa-or-html-wrapper"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mobile-native-js-pwa-or-html-wrapper"}},[e._v("#")]),e._v(" Mobile: Native JS, PWA or HTML Wrapper?")]),e._v(" "),a("p",[e._v("There are three major ways to provide an application for mobile devices:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("PWA")]),e._v(": Progressive Web App. Supported both on iOS and Android, they allow you to install a pure web HTML5 application to the device which can run even if offline. They do not require app stores, and essentially let you add a icon to the home screen of the device. The advantage is that they require very little to convert an existing SPA to work with. The disadvantage is that they are essentially the same as running your code on a browser, so you do not have a native performance or access to any APIs other than HTML5. You also have to install the app through the website, not through an app store. PWAs can also be installed to desktops. You can provide a PWA even if you have a native or HTML wrapped application.")]),e._v(" "),a("li",[a("strong",[e._v("HTML Wrapper")]),e._v(": this allows you to wrap your code into a native app, which will be available in app stores, using a wrapper such as "),a("a",{attrs:{href:"https://cordova.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cordova"),a("OutboundLink")],1),e._v(". It still runs HTML using the native web browser from your device, but you get access to native APIs through a JS wrapper, so it's a half-and-half solution. This can be a good solution in terms of cost/benefit, since you don't need to write a second view layer and yet you can get access to (and even write) native code through plugins. Any code specific to the app can be written in "),a("code",[e._v("if")]),e._v(" or loaded by the bundler. The interface is pure HTML though, and you might run into trouble if you are mixing native widgets with HTML. We'll not cover Cordova in this book.")]),e._v(" "),a("li",[a("strong",[e._v("native apps from JS")]),e._v(": in this case you write your logic in JS (and share it with the Web version), but you have native rendering of the interface instead of HTML5. This makes your interface faster and you can easily integrate native widgets. You add considerable development time to design the native views, but much less than developing separate codes for iOS and Android in native languages, but with the same performance. You get access to native APIs straight from JS, and you still can write plugins using native code if you want.")])]),e._v(" "),a("p",[e._v("Your choice should be based on the features you need on your application and how much time and money you are willing to spend. This books details how to build a Nativescript application, but we also have a section below explaining in more detail how to "),a("a",{attrs:{href:"#setting-up-pwa"}},[e._v("setup PWA")]),e._v(".")])])}),[],!1,null,null,null);t.default=i.exports}}]);